
╔════════════════════════════════════════════════════════════╗
║  Benchmark 1: Memory Churn                                ║
║  Allocate and discard objects rapidly                     ║
╚════════════════════════════════════════════════════════════╝

  Completed batch 0/100
  Completed batch 20/100
  Completed batch 40/100
  Completed batch 60/100
  Completed batch 80/100

Results:
  Total batches:              100
  Objects per batch:          1,000
  Total objects created:      100000
  Total execution time:       0.002936 seconds
  Time per batch:             0.000029 seconds

╔════════════════════════════════════════════════════════════╗
║           Garbage Collection Performance Report           ║
╚════════════════════════════════════════════════════════════╝

Memory Statistics:
  Total objects allocated:    100000
  Total objects freed:        100000
  Objects still alive:        0
  Peak heap size:             1000 objects
  Memory per object:          48 bytes
  Peak memory usage:          ~48000 bytes

Garbage Collection Statistics:
  Total GC invocations:       100
  Total GC time:              0.001729 seconds
  Average GC pause:           0.000017 seconds
  Min GC pause:               0.000016 seconds
  Max GC pause:               0.000022 seconds
  Average objects/collection: 1000.0

Collection Efficiency:
  Collection rate:            100.0%
  Survival rate:              0.0%

Performance Impact:
  Total instructions:         0

╚════════════════════════════════════════════════════════════╝

╔════════════════════════════════════════════════════════════╗
║  Benchmark 2: Long-lived Objects                          ║
║  Create objects and keep references                       ║
╚════════════════════════════════════════════════════════════╝

  Creating 50,000 long-lived objects...
    Created 10000 objects...
    Created 20000 objects...
    Created 30000 objects...
    Created 40000 objects...
  Running periodic GC...
    GC #1: 50000 objects alive
    GC #2: 50000 objects alive
    GC #3: 50000 objects alive
    GC #4: 50000 objects alive
    GC #5: 50000 objects alive
    GC #6: 50000 objects alive
    GC #7: 50000 objects alive
    GC #8: 50000 objects alive
    GC #9: 50000 objects alive
    GC #10: 50000 objects alive

Results:
  Objects created:            50000
  Objects surviving:          50000
  Total execution time:       0.010868 seconds

╔════════════════════════════════════════════════════════════╗
║           Garbage Collection Performance Report           ║
╚════════════════════════════════════════════════════════════╝

Memory Statistics:
  Total objects allocated:    50000
  Total objects freed:        0
  Objects still alive:        50000
  Peak heap size:             50000 objects
  Memory per object:          48 bytes
  Peak memory usage:          ~2400000 bytes

Garbage Collection Statistics:
  Total GC invocations:       10
  Total GC time:              0.010030 seconds
  Average GC pause:           0.001003 seconds
  Min GC pause:               0.000693 seconds
  Max GC pause:               0.001316 seconds
  Average objects/collection: 0.0

Collection Efficiency:
  Collection rate:            0.0%
  Survival rate:              100.0%

Performance Impact:
  Total instructions:         0

╚════════════════════════════════════════════════════════════╝

╔════════════════════════════════════════════════════════════╗
║  Benchmark 3: Mixed Workload                              ║
║  Mix of short-lived and long-lived objects                ║
╚════════════════════════════════════════════════════════════╝

  Creating 1,000 long-lived objects...
  Running mixed allocation/collection cycles...
    Cycle 0: heap=1000, collected=1000
    Cycle 10: heap=1000, collected=11000
    Cycle 20: heap=1000, collected=21000
    Cycle 30: heap=1000, collected=31000
    Cycle 40: heap=1000, collected=41000

Results:
  Total objects created:      51000
  Objects collected:          50000
  Objects surviving:          1000
  Total execution time:       0.001627 seconds

╔════════════════════════════════════════════════════════════╗
║           Garbage Collection Performance Report           ║
╚════════════════════════════════════════════════════════════╝

Memory Statistics:
  Total objects allocated:    51000
  Total objects freed:        50000
  Objects still alive:        1000
  Peak heap size:             2000 objects
  Memory per object:          48 bytes
  Peak memory usage:          ~96000 bytes

Garbage Collection Statistics:
  Total GC invocations:       50
  Total GC time:              0.001236 seconds
  Average GC pause:           0.000025 seconds
  Min GC pause:               0.000024 seconds
  Max GC pause:               0.000026 seconds
  Average objects/collection: 1000.0

Collection Efficiency:
  Collection rate:            98.0%
  Survival rate:              2.0%

Performance Impact:
  Total instructions:         0

╚════════════════════════════════════════════════════════════╝

╔════════════════════════════════════════════════════════════╗
║  Benchmark 4: GC Overhead Analysis                        ║
║  Measure time with and without GC                         ║
╚════════════════════════════════════════════════════════════╝

  Test 1: WITH garbage collection
    Allocated 10,000 objects with periodic GC
    Time: 0.000243 seconds
    GC calls: 100
    Total GC time: 0.000151 seconds

  Test 2: WITHOUT garbage collection
    Allocated 10,000 objects without GC
    Time: 0.000094 seconds
    Final heap size: 10000 objects

  Analysis:
    Allocation time:            0.000094 seconds
    Allocation + GC time:       0.000243 seconds
    GC overhead:                0.000151 seconds (62.1%)
